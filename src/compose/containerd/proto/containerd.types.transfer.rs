// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageStore {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "3")]
    pub platforms: ::prost::alloc::vec::Vec<super::Platform>,
    #[prost(bool, tag = "4")]
    pub all_metadata: bool,
    #[prost(uint32, tag = "5")]
    pub manifest_limit: u32,
    /// extra_references are used to set image names on imports of sub-images from the index
    #[prost(message, repeated, tag = "6")]
    pub extra_references: ::prost::alloc::vec::Vec<ImageReference>,
    #[prost(message, repeated, tag = "10")]
    pub unpacks: ::prost::alloc::vec::Vec<UnpackConfiguration>,
}
impl ::prost::Name for ImageStore {
    const NAME: &'static str = "ImageStore";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.ImageStore".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.ImageStore".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnpackConfiguration {
    /// platform is the platform to unpack for, used for resolving manifest and snapshotter
    /// if not provided
    #[prost(message, optional, tag = "1")]
    pub platform: ::core::option::Option<super::Platform>,
    /// snapshotter to unpack to, if not provided default for platform shoudl be used
    #[prost(string, tag = "2")]
    pub snapshotter: ::prost::alloc::string::String,
}
impl ::prost::Name for UnpackConfiguration {
    const NAME: &'static str = "UnpackConfiguration";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.UnpackConfiguration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.UnpackConfiguration".into()
    }
}
/// ImageReference is used to create or find a reference for an image
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageReference {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// is_prefix determines whether the Name should be considered
    /// a prefix (without tag or digest).
    /// For lookup, this may allow matching multiple tags.
    /// For store, this must have a tag or digest added.
    #[prost(bool, tag = "2")]
    pub is_prefix: bool,
    /// allow_overwrite allows overwriting or ignoring the name if
    /// another reference is provided (such as through an annotation).
    /// Only used if IsPrefix is true.
    #[prost(bool, tag = "3")]
    pub allow_overwrite: bool,
    /// add_digest adds the manifest digest to the reference.
    /// For lookup, this allows matching tags with any digest.
    /// For store, this allows adding the digest to the name.
    /// Only used if IsPrefix is true.
    #[prost(bool, tag = "4")]
    pub add_digest: bool,
    /// skip_named_digest only considers digest references which do not
    /// have a non-digested named reference.
    /// For lookup, this will deduplicate digest references when there is a named match.
    /// For store, this only adds this digest reference when there is no matching full
    /// name reference from the prefix.
    /// Only used if IsPrefix is true.
    #[prost(bool, tag = "5")]
    pub skip_named_digest: bool,
}
impl ::prost::Name for ImageReference {
    const NAME: &'static str = "ImageReference";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.ImageReference".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.ImageReference".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageImportStream {
    /// Stream is used to identify the binary input stream for the import operation.
    /// The stream uses the transfer binary stream protocol with the client as the sender.
    /// The binary data is expected to be a raw tar stream.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub media_type: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force_compress: bool,
}
impl ::prost::Name for ImageImportStream {
    const NAME: &'static str = "ImageImportStream";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.ImageImportStream".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.ImageImportStream".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageExportStream {
    /// Stream is used to identify the binary output stream for the export operation.
    /// The stream uses the transfer binary stream protocol with the server as the sender.
    /// The binary data is expected to be a raw tar stream.
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub media_type: ::prost::alloc::string::String,
    /// The specified platforms
    #[prost(message, repeated, tag = "3")]
    pub platforms: ::prost::alloc::vec::Vec<super::Platform>,
    /// Whether to include all platforms
    #[prost(bool, tag = "4")]
    pub all_platforms: bool,
    /// Skips the creation of the Docker compatible manifest.json file
    #[prost(bool, tag = "5")]
    pub skip_compatibility_manifest: bool,
    /// Excludes non-distributable blobs such as Windows base layers.
    #[prost(bool, tag = "6")]
    pub skip_non_distributable: bool,
}
impl ::prost::Name for ImageExportStream {
    const NAME: &'static str = "ImageExportStream";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.ImageExportStream".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.ImageExportStream".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Progress {
    #[prost(string, tag = "1")]
    pub event: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub parents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub progress: i64,
    #[prost(int64, tag = "5")]
    pub total: i64,
    #[prost(message, optional, tag = "6")]
    pub desc: ::core::option::Option<super::Descriptor>,
}
impl ::prost::Name for Progress {
    const NAME: &'static str = "Progress";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.Progress".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.Progress".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OciRegistry {
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub resolver: ::core::option::Option<RegistryResolver>,
}
impl ::prost::Name for OciRegistry {
    const NAME: &'static str = "OCIRegistry";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.OCIRegistry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.OCIRegistry".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistryResolver {
    /// auth_stream is used to refer to a stream which auth callbacks may be
    /// made on.
    #[prost(string, tag = "1")]
    pub auth_stream: ::prost::alloc::string::String,
    /// Headers
    #[prost(map = "string, string", tag = "2")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "3")]
    pub host_dir: ::prost::alloc::string::String,
    /// Force skip verify
    /// CA callback? Client TLS callback?
    #[prost(string, tag = "4")]
    pub default_scheme: ::prost::alloc::string::String,
    /// Whether to debug/trace HTTP requests to OCI registry.
    #[prost(enumeration = "HttpDebug", tag = "5")]
    pub http_debug: i32,
    /// Stream ID to use for HTTP logs (when logs are streamed to client).
    /// When empty, logs are written to containerd logs.
    #[prost(string, tag = "6")]
    pub logs_stream: ::prost::alloc::string::String,
}
impl ::prost::Name for RegistryResolver {
    const NAME: &'static str = "RegistryResolver";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.RegistryResolver".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.RegistryResolver".into()
    }
}
/// AuthRequest is sent as a callback on a stream
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthRequest {
    /// host is the registry host
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// reference is the namespace and repository name requested from the registry
    #[prost(string, tag = "2")]
    pub reference: ::prost::alloc::string::String,
    /// wwwauthenticate is the HTTP WWW-Authenticate header values returned from the registry
    #[prost(string, repeated, tag = "3")]
    pub wwwauthenticate: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for AuthRequest {
    const NAME: &'static str = "AuthRequest";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.AuthRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.AuthRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthResponse {
    #[prost(enumeration = "AuthType", tag = "1")]
    pub auth_type: i32,
    #[prost(string, tag = "2")]
    pub secret: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    /// TODO: Stream error
    #[prost(message, optional, tag = "4")]
    pub expire_at: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for AuthResponse {
    const NAME: &'static str = "AuthResponse";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.AuthResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.AuthResponse".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HttpDebug {
    Disabled = 0,
    /// Enable HTTP debugging
    Debug = 1,
    /// Enable HTTP requests tracing
    Trace = 2,
    /// Enable both HTTP debugging and requests tracing
    Both = 3,
}
impl HttpDebug {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Disabled => "DISABLED",
            Self::Debug => "DEBUG",
            Self::Trace => "TRACE",
            Self::Both => "BOTH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISABLED" => Some(Self::Disabled),
            "DEBUG" => Some(Self::Debug),
            "TRACE" => Some(Self::Trace),
            "BOTH" => Some(Self::Both),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthType {
    None = 0,
    /// CREDENTIALS is used to exchange username/password for access token
    /// using an oauth or "Docker Registry Token" server
    Credentials = 1,
    /// REFRESH is used to exchange secret for access token using an oauth
    /// or "Docker Registry Token" server
    Refresh = 2,
    /// HEADER is used to set the HTTP Authorization header to secret
    /// directly for the registry.
    /// Value should be `<auth-scheme> <authorization-parameters>`
    Header = 3,
}
impl AuthType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "NONE",
            Self::Credentials => "CREDENTIALS",
            Self::Refresh => "REFRESH",
            Self::Header => "HEADER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "CREDENTIALS" => Some(Self::Credentials),
            "REFRESH" => Some(Self::Refresh),
            "HEADER" => Some(Self::Header),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for Data {
    const NAME: &'static str = "Data";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.Data".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.Data".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindowUpdate {
    #[prost(int32, tag = "1")]
    pub update: i32,
}
impl ::prost::Name for WindowUpdate {
    const NAME: &'static str = "WindowUpdate";
    const PACKAGE: &'static str = "containerd.types.transfer";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.transfer.WindowUpdate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.transfer.WindowUpdate".into()
    }
}
