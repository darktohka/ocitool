// This file is @generated by prost-build.
/// Descriptor describes a blob in a content store.
///
/// This descriptor can be used to reference content from an
/// oci descriptor found in a manifest.
/// See <https://godoc.org/github.com/opencontainers/image-spec/specs-go/v1#Descriptor>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Descriptor {
    #[prost(string, tag = "1")]
    pub media_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub digest: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub size: i64,
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for Descriptor {
    const NAME: &'static str = "Descriptor";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.Descriptor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.Descriptor".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metric {
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub data: ::core::option::Option<::prost_types::Any>,
}
impl ::prost::Name for Metric {
    const NAME: &'static str = "Metric";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.Metric".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.Metric".into()
    }
}
/// Mount describes mounts for a container.
///
/// This type is the lingua franca of ContainerD. All services provide mounts
/// to be used with the container at creation time.
///
/// The Mount type follows the structure of the mount syscall, including a type,
/// source, target and options.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mount {
    /// Type defines the nature of the mount.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Source specifies the name of the mount. Depending on mount type, this
    /// may be a volume name or a host path, or even ignored.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// Target path in container
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Options specifies zero or more fstab style mount options.
    #[prost(string, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for Mount {
    const NAME: &'static str = "Mount";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.Mount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.Mount".into()
    }
}
/// Platform follows the structure of the OCI platform specification, from
/// descriptors.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Platform {
    #[prost(string, tag = "1")]
    pub os: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub architecture: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub variant: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub os_version: ::prost::alloc::string::String,
}
impl ::prost::Name for Platform {
    const NAME: &'static str = "Platform";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.Platform".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.Platform".into()
    }
}
/// Sandbox represents a sandbox metadata object that keeps all info required by controller to
/// work with a particular instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sandbox {
    /// SandboxID is a unique instance identifier within namespace
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Runtime specifies which runtime to use for executing this container.
    #[prost(message, optional, tag = "2")]
    pub runtime: ::core::option::Option<sandbox::Runtime>,
    /// Spec is sandbox configuration (kin of OCI runtime spec), spec's data will be written to a config.json file in the
    /// bundle directory (similary to OCI spec).
    #[prost(message, optional, tag = "3")]
    pub spec: ::core::option::Option<::prost_types::Any>,
    /// Labels provides an area to include arbitrary data on containers.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// CreatedAt is the time the container was first created.
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// UpdatedAt is the last time the container was mutated.
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Extensions allow clients to provide optional blobs that can be handled by runtime.
    #[prost(map = "string, message", tag = "7")]
    pub extensions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Any,
    >,
    /// Sandboxer is the name of the sandbox controller who manages the sandbox.
    #[prost(string, tag = "10")]
    pub sandboxer: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Sandbox`.
pub mod sandbox {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Runtime {
        /// Name is the name of the runtime.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Options specify additional runtime initialization options for the shim (this data will be available in StartShim).
        /// Typically this data expected to be runtime shim implementation specific.
        #[prost(message, optional, tag = "2")]
        pub options: ::core::option::Option<::prost_types::Any>,
    }
    impl ::prost::Name for Runtime {
        const NAME: &'static str = "Runtime";
        const PACKAGE: &'static str = "containerd.types";
        fn full_name() -> ::prost::alloc::string::String {
            "containerd.types.Sandbox.Runtime".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/containerd.types.Sandbox.Runtime".into()
        }
    }
}
impl ::prost::Name for Sandbox {
    const NAME: &'static str = "Sandbox";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.Sandbox".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.Sandbox".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Envelope {
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub event: ::core::option::Option<::prost_types::Any>,
}
impl ::prost::Name for Envelope {
    const NAME: &'static str = "Envelope";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.Envelope".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.Envelope".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeRequest {
    #[prost(string, tag = "1")]
    pub runtime_path: ::prost::alloc::string::String,
    /// Options correspond to CreateTaskRequest.options.
    /// This is needed to pass the runc binary path, etc.
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<::prost_types::Any>,
}
impl ::prost::Name for RuntimeRequest {
    const NAME: &'static str = "RuntimeRequest";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.RuntimeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.RuntimeRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeVersion {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub revision: ::prost::alloc::string::String,
}
impl ::prost::Name for RuntimeVersion {
    const NAME: &'static str = "RuntimeVersion";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.RuntimeVersion".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.RuntimeVersion".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub version: ::core::option::Option<RuntimeVersion>,
    /// Options correspond to RuntimeInfoRequest.Options (contains runc binary path, etc.)
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<::prost_types::Any>,
    /// OCI-compatible runtimes should use <https://github.com/opencontainers/runtime-spec/blob/main/features.md>
    #[prost(message, optional, tag = "4")]
    pub features: ::core::option::Option<::prost_types::Any>,
    /// Annotations of the shim. Irrelevant to features.Annotations.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for RuntimeInfo {
    const NAME: &'static str = "RuntimeInfo";
    const PACKAGE: &'static str = "containerd.types";
    fn full_name() -> ::prost::alloc::string::String {
        "containerd.types.RuntimeInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/containerd.types.RuntimeInfo".into()
    }
}
